<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Card Sorting</title>
  <!-- Icons -->
  <link rel="stylesheet" type="text/css" href="https://unpkg.com/@phosphor-icons/web@2.0.3/src/fill/style.css">
  <link rel="stylesheet" type="text/css" href="https://unpkg.com/@phosphor-icons/web@2.0.3/src/regular/style.css">
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Sans+Display:wght@300;500&family=Noto+Sans+Mono&family=Noto+Sans:wght@400;600&display=swap"
    rel="stylesheet">
  <style>
    /* Reset */
    body,
    html {
      margin: 0;
      padding: 0;
      font-family: "Noto Sans", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    /* Layout */
    .main-layout {
      display: grid;
      grid-template-columns: auto 1fr;
      grid-template-rows: minmax(60px, min-content) 1fr;
      gap: 1rem;
      grid-template-areas:
        "top top"
        "left right";
      margin: 1rem;
    }

    .toolbar {
      grid-area: top;
    }

    .uncategorized-cards {
      position: relative;
      grid-area: left;
    }

    .categories {
      position: relative;
      grid-area: right;
    }

    /* Muuri functional */
    .grid {
      position: relative;
    }

    .item {
      display: block;
      position: absolute;
    }

    .item.muuri-item-dragging {
      z-index: 3;
    }

    .item.muuri-item-dragging .card {
      box-shadow: 0 0 20px #6A798755;
      transform: rotate(5deg);
      transform-origin: center;
    }

    .item.muuri-item-releasing {
      z-index: 2;
    }

    .item.muuri-item-hidden {
      z-index: 0;
    }

    .item-content {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .categories .item-content .card {
      max-width: 100%;
      margin: 0;
    }

    /* Toolbar */
    .toolbar {
      display: flex;
      align-items: center;
      justify-content: end;
      gap: 1rem;
    }

    .toolbar button {
      padding: .55em 1em .45em;
      min-height: 45px;
      border: 0;
      cursor: pointer;
      background-color: #0E2A3C;
      color: #fff;
      font-family: "Noto Sans", sans-serif;
      font-size: 1.25rem;
    border-radius: 5px;

    }

    button.btn-secondary {
      background-color: #ACBAC8;
      color: black;
    }

    button:focus {
      outline: 2px solid #B79000;
      outline-offset: 2px;
    }

    /* Uncategorized cards */
    .uncategorized-cards {
      
      width: 500px;
      max-width: calc(50vw - 35px);
    }

    .uncategorized-cards .grid {
      min-height: 100%;
    }

    .uncategorized-cards .item {
      width: 100%;
    }

    .card {
      max-width: calc(50vw - 45px);
      margin: 0.5rem;
      font-size: 1.0625rem;
      cursor: grab;
      background-color: #ACBAC8;
      border-radius: 3px;
    }

    .card span {
      display: block;
    }

    .card[data-type="sms"] {
      width: 230px;
      padding: 0.5rem;
      border-radius: 16px;
      border-bottom-left-radius: 0px;
    }
    .card[data-type="email"] {
      width: 480px;
      border: 2px solid #ACBAC8;
      border-top-width: 12px;
      background-color: white;
      padding-inline: 0rem;
    }

    .card[data-type="email"] .subject {
      font-size: 20px;
      padding-block: 0.5rem;
    }

    .card[data-type="email"] > div {
      border-top: 2px solid #ACBAC8;
      padding-inline: 0.5rem;
    }

    .card[data-type="email"] .type {
      padding-inline: 0.5rem;
    }

    .card .type {

    }

    .card .card-image {
      width: 100%;
    }

    .card .card-image-text:first-child {
      display: inline-block;
      margin-bottom: 4px;
    }

    .muuri-item-placeholder .card {
      pointer-events: none;
      background: transparent;
      border: 2px dashed #bbb;
      color: #999;
      box-shadow: none;
    }

    .muuri-item-placeholder .card .card-image {
      filter: grayscale(1);
      opacity: .3;
    }

    /* Categories */
    .category {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin: 1rem 2rem;
      padding: 0.5rem;
      padding-bottom: 0;
      background: #fff;
      border-radius: 12px;
      border: 2px solid #ACBAC8;
    }

    .category .title {
      font-size: 1.5rem;
      color: inherit;
    }
    .category .description {
      color: #384149;
    }

    .category [contenteditable] {
      max-width: calc(50vw - 45px);
      width: 480px;
      padding: 5px 4px 4px;
    border: 2px solid transparent;
    border-radius: 3px;
margin: 0;
    }
.category [contenteditable]:hover {
    border: 2px solid #ACBAC8;

}
.category [contenteditable]:focus {
  border: 2px solid black;
  outline: 2px solid #B79000;
  outline-offset: 2px;
}


    .category-cards .grid {
      min-height: 100px;
    }

    .category-cards .item {
      width: 100%;
    }

    .category-drag-handle {
      width: 100%;
      height: 16px;
      background: radial-gradient(#ACBAC8 35%, transparent 36%) 0 0;
      background-color: #fff;
      background-size: 8px 8px;
      cursor: grab;
    }
  </style>
  </head>

<body>
  <div class="main-layout">
    <div class="toolbar">
      <button class="btn-create-category">Create a new category</button>
      <button class="btn-share-result btn-secondary">Share result</button>
      <button class="btn-export-result btn-secondary">Export result</button>
      </div>
      <div class="uncategorized-cards">
        <div class="grid"></div>
      </div>
      <div class="categories">
        <div class="grid"></div>
      </div>
      </div>
      <template class="card-template">
        <div class="item">
          <div class="item-content">
        <div class="card">
          <span class="type">Type</span>
          <div class="subject">Subject</div>
          <div class="content">Content</div>
        </div>
        </div>
        </div>
        </template>
        <template class="category-template">
          <div class="item">
            <div class="item-content">
              <div class="category">
                <div class="category-controls">
                  <div class="category-drag-handle"></div>
                </div>
          <div class="category-meta">
            <p contenteditable="true" class="title" placeholder="Type a name">Type a name</p>
            <p contenteditable="true" class="description" placeholder="Add a description">Add a description</p>
          </div>
          <div class="category-cards">
            <div class="grid"></div>
          </div>
          </div>
          </div>
          </div>
          </template>
          <script src="muuri-0.9.5.min.js"></script>
          <script src="pako-2.0.4.min.js"></script>
          <script src="common-scripts.js"></script>
          <script src="
                                        https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js
                                        "></script>
          <script>

  const md = markdownit()
                  let data = {};
                  const settings = Object.assign({}, settingsDefaults);

      /* Card sorting */
      const buttonCreateCategory = document.querySelector('.btn-create-category');
      const buttonShareResult = document.querySelector('.btn-share-result');
      const buttonExportResult = document.querySelector('.btn-export-result');
      const cardTemplate = document.querySelector('.card-template');
      const categoryTemplate = document.querySelector('.category-template');
      const cardImageRegex = /\s*image\s*:\s*((?:https?|data):\S+)/i;
      const uncategorizedCardsGrid = new Muuri('.uncategorized-cards .grid', {
        dragEnabled: true,
        dragSort: () => cardGrids,
        dragPlaceholder: {
          enabled: true,
          createElement: (item) => item.getElement().cloneNode(true),
        },
        dragAutoScroll: {
          targets: [window],
          sortDuringScroll: false,
        },
      });
      const categoriesGrid = new Muuri('.categories .grid', {
        dragEnabled: true,
        dragSort: true,
        dragHandle: '.category-drag-handle',
        layoutOnResize: false,
      }).on('layoutEnd', () => categoriesGrid.synchronize());
      const cardGrids = [uncategorizedCardsGrid];

      const debouncedUpdateData = debounce(updateData, 500);
      initialize();

      async function initialize() {
        if (!window.location.hash) {
          if (window.location.search) {
            data = loadFromQueryParameters();
          }
          else {
            window.location.href = 'index.html';
            return;
          }
        }
        else {
          data = await loadFromString(window.location.hash.split('#').pop());
        }
        const cardTexts = data[uncategorizedKey];
        Object.assign(settings, loadSettings(data));
        if (settings.allowCategoryEditing === false) {
          buttonCreateCategory.style.display = 'none';

          categoryTemplate.content.querySelectorAll('[contenteditable]').forEach(item => {
            item.disabled = true;
            item.removeAttribute('placeholder');
          })
          //categoryTemplate.content.querySelector('.title').disabled = true;
          //categoryTemplate.content.querySelector('.title').removeAttribute('placeholder');
        }
        buttonCreateCategory.addEventListener('click', () => createCategory());
        if (settings.isRandomized) {
          cardTexts.sort(() => Math.random() - 0.5);
        }
        for (const text of cardTexts) {
          createCard(text);
        }
        const categories = Object.keys(data).filter(categoryName => !reservedKeys.includes(categoryName));
        console.log(categories)

        if (categories.length > 0) {
          for (categoryName of categories) {
            createCategory(categoryName);
          }
        }
        else {
          createCategory();
          createCategory();
          createCategory();
        }
        uncategorizedCardsGrid.on('dragEnd', function handleDragEnd(data) {
          debouncedUpdateData();
          categoriesGrid.refreshItems().layout();
        });
        buttonShareResult.addEventListener('click', shareResult);
        buttonExportResult.addEventListener('click', exportResult);
        // Fix for window resize caused by virtual keyboard
        // Muuri layout is deferred until input loses focus
        let isDeferredResize = false;
        window.addEventListener('resize', debounce(function handleWindowResize() {
          if (document.activeElement.tagName.toLowerCase() === 'input') {
            isDeferredResize = true;
            return;
          }
          categoriesGrid.refreshItems().layout();
        }, Muuri.defaultOptions.layoutOnResize));
        document.addEventListener('focusout', function handleInputDefocus() {
          if (!isDeferredResize) {
            return;
          }
          categoriesGrid.refreshItems().layout();
          isDeferredResize = false;
        });
      }

      function createCard(text, categoryGrid) {
        const targetGrid = categoryGrid || uncategorizedCardsGrid;
        const itemElement = document.importNode(cardTemplate.content.children[0], true);
        const cardElement = itemElement.querySelector('.card');
        const cardType = cardElement.querySelector('.type')
        const cardSubject = cardElement.querySelector('.subject')
        const cardContent = cardElement.querySelector('.content')
        const hasImage = false; //text.match(cardImageRegex);
        if (hasImage) {
          const [textBefore, imageUrl, textAfter] = text.split(cardImageRegex);
          const cardChildElements = [];
          if (textBefore.trim()) {
            const span = document.createElement('span');
            span.className = 'card-image-text';
            span.appendChild(document.createTextNode(textBefore));
            cardChildElements.push(span);
          }
          const imageElement = document.createElement('img');
          imageElement.className = 'card-image';
          imageElement.onload = () => targetGrid.refreshItems().layout();
          imageElement.src = imageUrl;
          cardChildElements.push(imageElement);
          if (textAfter.trim()) {
            const span = document.createElement('span');
            span.className = 'card-image-text';
            span.appendChild(document.createTextNode(textAfter));
            cardChildElements.push(span);
          }
          cardElement.replaceChildren(...cardChildElements);
        }
        else {
          cardElement.setAttribute("data-type", text[0])
          cardType.textContent = text[0];
          if (text[1]) {
            cardSubject.textContent = text[1];
          }
          else {
            cardSubject.remove()
          }
          if (cardElement.getAttribute("data-type") === "email") {
            cardContent.innerHTML = md.render(text[2]);
            //cardContent.textContent = text[2];


          } else {
            cardContent.textContent = text[2];

          }

        }
        cardElement.setAttribute('data-text', text);
        targetGrid.show(
          targetGrid.add([itemElement], {
            active: false,
          }),
          {
            onFinish: () => {
              categoriesGrid.refreshItems().layout();
              targetGrid.refreshItems().layout()
            },
          },
        );
      }

      function createCategory(name, cards) {
        const itemElement = document.importNode(categoryTemplate.content.children[0], true);
        const titleInput = itemElement.querySelector('.title');
        const descriptionInput = itemElement.querySelector('.description');
        titleInput.addEventListener('input', function handleInput() {
          debouncedUpdateData();
        });
        descriptionInput.addEventListener('input', function handleInput() {
          debouncedUpdateData();
        });
        if (name) {
          titleInput.textContent = name.split(";")[0];
          descriptionInput.textContent = name.split(";")[1] || "";
        }
        else if (settings.allowCategoryEditing === false) {
          itemElement.setAttribute("data-editing", "false")
        }
        categoriesGrid.show(
          categoriesGrid.add([itemElement], {
            active: false,
            index: !!name ? -1 : 0,
          }),
          {
            onFinish: () => {
              const categoryGrid = new Muuri(itemElement.querySelector('.grid'), {
                dragEnabled: true,
                dragSort: () => cardGrids,
                dragPlaceholder: {
                  enabled: true,
                  createElement: (item) => item.getElement().cloneNode(true),
                },
                dragContainer: document.body,
                dragAutoScroll: {
                  targets: [window],
                  sortDuringScroll: false,
                },
              });
              categoryGrid.on('dragEnd', function handleDragEnd(data) {
                categoriesGrid.refreshItems().layout();
              });
              categoryGrid.on('dragReleaseEnd', function handleDragReleaseEnd(data) {
                categoryGrid.synchronize();
                debouncedUpdateData();
              });
              cardGrids.push(categoryGrid);
              const cardTexts = data[name] || [];
              for (const text of cardTexts) {
                createCard(text, categoryGrid);
              }
            },
          }
        );
      }

      function updateData() {
        let untitledCounter = 0;
        data = {};
        for (const categoryElement of document.querySelectorAll('.category')) {
          let categoryName = categoryElement.querySelector('.title').textContent;
          if (!categoryName) {
            untitledCounter += 1;
            categoryName = `(Untitled ${untitledCounter})`;
          }
          if (categoryName in data) {
            categoryName = getUniqueCategoryName(categoryName, data);
          }
          data[categoryName] = [];
          for (const cardElement of categoryElement.querySelectorAll('.card')) {
            data[categoryName].push(cardElement.getAttribute('data-text'));
          }
        }
        data[uncategorizedKey] = [];
        for (const cardElement of document.querySelectorAll('.uncategorized-cards .card')) {
          data[uncategorizedKey].push(cardElement.getAttribute('data-text'));
        }
        data[settingsFlagsKey] = saveSettings(settings);
      }

      function getUniqueCategoryName(originalName, data) {
        let candidateName = originalName
        let counter = 1;
        while (candidateName in data) {
          counter += 1;
          candidateName = `${originalName} (${counter})`;
        }
        return candidateName;
      }

      async function shareResult() {
        updateData();
        const dataString = await saveToString(data);
        const baseUrl = window.location.href.replace(regexRemoveBasenameFromUrl, '/');
        const url = baseUrl + 'card-sort.html#' + dataString;
        if (navigator.share) {
          navigator.share({
            title: '',
            text: '',
            url: url,
          });
        }
        else if (navigator.clipboard) {
          navigator.clipboard.writeText(url);
          const originalText = buttonShareResult.textContent;
          buttonShareResult.textContent = 'Link copied to clipboard';
          clearTimeout(buttonShareResult._textTimeout);
          buttonShareResult._textTimeout = setTimeout(() => {
            buttonShareResult.textContent = originalText;
          }, 5000);
        }
        else {
          window.location.href = url;
          alert('Your browser does not support sharing. Please copy from the address bar instead.');
        }
      }

      function exportResult() {
        updateData();
        const cleanedData = {};
        for ([key, value] of Object.entries(data)) {
          if (reservedKeys.includes(key)) {
            continue;
          }
          cleanedData[key] = value;
        }
        const serializedData = JSON.stringify(cleanedData, null, 2);
        if (navigator.clipboard) {
          navigator.clipboard.writeText(serializedData);
          const originalText = buttonExportResult.textContent;
          buttonExportResult.textContent = 'Data copied to clipboard';
          clearTimeout(buttonExportResult._textTimeout);
          buttonExportResult._textTimeout = setTimeout(() => {
            buttonExportResult.textContent = originalText;
          }, 5000);
        }
        else {
          prompt('Your browser does not support clipboard. You may try copying the content from below.', serializedData);
        }
      }
    </script>
  </body>

</html>